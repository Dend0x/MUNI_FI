VÂ tÃ©to kapitole budeme potÅ™ebovat 2 typy instrukcÃ­ â€“ vÃ½poÄetnÃ­
(aritmetickÃ©, logickÃ©, atp.) a instrukce pro Å™Ã­zenÃ­ toku
(nepodmÃ­nÄ›nÃ© a podmÃ­nÄ›nÃ© skoky). ZejmÃ©na prozatÃ­m nebudeme
potÅ™ebovat pracovat sÂ adresami, pamÄ›tÃ­ obecnÄ›, ani zÃ¡sobnÃ­kem.

## KopÃ­rovÃ¡nÃ­ hodnot

NejzÃ¡kladnÄ›jÅ¡Ã­ operacÃ­, kterou mÅ¯Å¾eme vÂ programu potÅ™ebovat, je
nastavenÃ­ registru, a to buÄ na pÅ™edem znÃ¡mou konstantu, nebo na
hodnotu aktuÃ¡lnÄ› uloÅ¾enou vÂ nÄ›kterÃ©m jinÃ©m registru.

KÂ nastavenÃ­ registru na konstantu mÅ¯Å¾eme pouÅ¾Ã­t operaci â€¹putâ€º, kterÃ¡
nastavÃ­ vÃ½stupnÃ­ registr na hodnotu pÅ™Ã­mÃ©ho operandu. ZÃ¡pis tÃ©to
instrukce bude vypadat napÅ™. takto:

    put 13   â†’ rv                                  ; tiny
    put 0x70 â†’ l1
    halt

Tento program nastavÃ­ registr â€¹rvâ€º na hodnotu 13 a registr â€¹l1â€º na
hodnotu 112.

Pro kopÃ­rovÃ¡nÃ­ hodnot mezi registry pouÅ¾ijeme operaci â€¹copyâ€º â€“ ta
nastavÃ­ vÃ½stupnÃ­ registr na tutÃ©Å¾ hodnotu, jakou mÃ¡ registr vstupnÃ­.
NapÅ™Ã­klad:

    put  13 â†’ rv                                   ; tiny
    put  17 â†’ l1
    copy rv â†’ l2 ; sets l2 = 13
    copy l1 â†’ rv ; sets rv = 17
    halt

Po provedenÃ­ tohoto programu budou hodnoty registrÅ¯ â€¹rv = 17â€º, â€¹l1 =
17â€º a â€¹l2 = 13â€º.

## Aritmetika

DalÅ¡Ã­ dÅ¯leÅ¾itou kategoriÃ­ jsou aritmetickÃ© instrukce. NÃ¡sledujÃ­cÃ­
tabulka shrnuje operace, kterÃ© mÃ¡te kÂ dispozici. Registr â€¹l1â€º
odpovÃ­dÃ¡ promÄ›nnÃ© â€¹aâ€º, registr â€¹l2â€º promÄ›nnÃ© â€¹bâ€º, registr â€¹rvâ€º pak
promÄ›nnÃ© â€¹xâ€º.

â”‚     nÃ¡zev â”‚       python â”‚               tiny â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–»â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚   sÄÃ­tÃ¡nÃ­ â”‚  â€¹x = a + bâ€º â”‚  â€¹add l1, l2 â†’ rvâ€º â”‚
â”‚ odeÄÃ­tÃ¡nÃ­ â”‚  â€¹x = a - bâ€º â”‚  â€¹sub l1, l2 â†’ rvâ€º â”‚
â”‚  nÃ¡sobenÃ­ â”‚  â€¹x = a * bâ€º â”‚  â€¹mul l1, l2 â†’ rvâ€º â”‚
â”‚    dÄ›lenÃ­ â”‚ â€¹x = a // bâ€º â”‚ â€¹sdiv l1, l2 â†’ rvâ€º â”‚
â”‚           â”‚              â”‚ â€¹udiv l1, l2 â†’ rvâ€º â”‚
â”‚    zbytek â”‚  â€¹x = a % bâ€º â”‚ â€¹smod l1, l2 â†’ rvâ€º â”‚
â”‚           â”‚              â”‚ â€¹umod l1, l2 â†’ rvâ€º â”‚

VÅ¡imnÄ›te si, Å¾e operaci celoÄÃ­selnÃ©ho dÄ›lenÃ­ a zbytku po dÄ›lenÃ­
odpovÃ­dajÃ­ dvÄ› rÅ¯znÃ© instrukce. Je to proto, Å¾e fyzicky jsou
registry realizovanÃ© jako sekvence binÃ¡rnÃ­ch pÅ™epÃ­naÄÅ¯ â€“ kaÅ¾dÃ½
pÅ™epÃ­naÄ reprezentuje jeden bit. Tyto binÃ¡rnÃ­ sekvence lze
interpretovat rÅ¯znÃ½mi zpÅ¯soby, nicmÃ©nÄ› âŸ¦bâŸ§-bitovÃ½ registr obvykle
chÃ¡peme jako:

 1. celÃ© ÄÃ­slo âŸ¦nâŸ§ bez znamÃ©nka vÂ rozsahu âŸ¦âŸ¨0, 2áµ‡)âŸ§ â€“ pak sekvence
    bitÅ¯ pÅ™Ã­mo odpovÃ­dÃ¡ binÃ¡rnÃ­mu zÃ¡pisu tohoto ÄÃ­sla,
 2. jako celÃ© ÄÃ­slo âŸ¦sâŸ§ se znamÃ©nkem vÂ rozsahu âŸ¦âŸ¨-2áµ‡â»Â¹, 2áµ‡â»Â¹)âŸ§, a to
    tak, Å¾e:
    
     a. je-li nejvyÅ¡Å¡Ã­ bit nastaven na 1, âŸ¦s = n - 2áµ‡âŸ§,
     b. jinak âŸ¦s = nâŸ§

    PodmÃ­nku zÂ bodu (a) mÅ¯Å¾eme takÃ© chÃ¡pat jako âŸ¦n â‰¥ 2áµ‡â»Â¹âŸ§.

Pro 16bitovÃ¡ ÄÃ­sla, kterÃ¡ budeme vÂ tomto pÅ™edmÄ›tu pouÅ¾Ã­vat zdaleka
nejÄastÄ›ji, to jsou tyto rozsahy:

 â€¢ âŸ¦âŸ¨0, 65535âŸ©âŸ§ (nebo â€¹0â€“ffffâ€º v Å¡estnÃ¡ctkovÃ©m zÃ¡pisu) pro
   reprezentaci bez znamÃ©nka,
 â€¢ âŸ¦âŸ¨-32768, 32767âŸ©âŸ§ (nebo â€¹-8000â€º aÅ¾ â€¹7fffâ€º Å¡estnÃ¡ctkovÄ›) pro
   reprezentaci se znamÃ©nkem.

Tato reprezentace mÃ¡ tu vlastnost, Å¾e sÄÃ­tÃ¡nÃ­, odeÄÃ­tÃ¡nÃ­ a nÃ¡sobenÃ­
pouÅ¾Ã­vÃ¡ na Ãºrovni bitÅ¯ stejnÃ½ algoritmus vÂ obou pÅ™Ã­padech â€“ proto
operace â€¹addâ€º funguje stejnÄ› dobÅ™e bez ohledu na to, chÃ¡peme-li
operandy jako znamÃ©nkovÃ© nebo bezznamÃ©nkovÃ©.

To ale neplatÃ­ pro dÄ›lenÃ­ (a nebude to platit ani pro srovnÃ¡nÃ­, jak
uvidÃ­me za chvÃ­li) â€“ vÃ½sledek se bude liÅ¡it vÂ zÃ¡vislosti na tom,
je-li operace znamÃ©nkovÃ¡ (â€¹sdivâ€º, â€¹smodâ€º) nebo nikoliv (â€¹udivâ€º,
â€¹umodâ€º).

## SrovnÃ¡nÃ­

Prakticky kaÅ¾dÃ½ vyÅ¡Å¡Ã­ programovacÃ­ jazyk mÃ¡ nÄ›jakou formu
Â«podmÃ­nÄ›nÃ©ho pÅ™Ã­kazuÂ». Aby byla tato konstrukce uÅ¾iteÄnÃ¡,
potÅ™ebujeme mÃ­t kÂ dispozici Â«predikÃ¡tyÂ» â€“ operace, kterÃ½ch vÃ½sledkem
je pravdivostnÃ­ hodnota. Ty nejbÄ›Å¾nÄ›jÅ¡Ã­ jiÅ¾ dobÅ™e znÃ¡te â€“ jsou to
celoÄÃ­selnÃ© srovnÃ¡vacÃ­ operÃ¡tory. VÂ Pythonu je zapisujeme jako â€¹a ==
bâ€º, â€¹a < bâ€º, atp.

NÃ¡Å¡ vÃ½poÄetnÃ­ stroj mÃ¡ pro tento ÃºÄel sadu operacÃ­ â€“ jsou shrnuty
vÂ tabulce nÃ­Å¾e. Jak jiÅ¾ bylo vÃ½Å¡e naznaÄeno, sÂ vÃ½jimkou rovnosti
musÃ­me rozliÅ¡ovat znamÃ©nkovou a bezznamÃ©nkovou verzi. Na rozdÃ­l od
Pythonu (nebo jazyka C) nemÃ¡ strojovÃ½ kÃ³d sloÅ¾enÃ© vÃ½razy, proto
musÃ­me vÃ½sledek srovnÃ¡nÃ­ vÅ¾dy uloÅ¾it do registru (analogem vÂ Pythonu
je booleovskÃ¡ promÄ›nnÃ¡ â€“ budeme ji zde opÄ›t znaÄit â€¹xâ€º).

â”‚       python â”‚               tiny â”‚          â”‚                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â–»â”¼â—…â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚ â€¹x = a == bâ€º â”‚  â€¹eq  l1, l2 â†’ rvâ€º â”‚          â”‚     ğğªual        â”‚
â”‚ â€¹x = a != bâ€º â”‚  â€¹ne  l1, l2 â†’ rvâ€º â”‚          â”‚ ğ§ot ğqual        â”‚
â”‚  â€¹x = a < bâ€º â”‚  â€¹slt l1, l2 â†’ rvâ€º â”‚   ğ¬igned â”‚ ğ¥ess ğ­han        â”‚
â”‚              â”‚  â€¹ult l1, l2 â†’ rvâ€º â”‚ ğ®nsigned â”‚ ğ¥ess ğ­han        â”‚
â”‚  â€¹x = a > bâ€º â”‚  â€¹sgt l1, l2 â†’ rvâ€º â”‚   ğ¬igned â”‚ ğ reater ğ­han     â”‚
â”‚              â”‚  â€¹ugt l1, l2 â†’ rvâ€º â”‚ ğ®nsigned â”‚ ğ reater ğ­han     â”‚
â”‚ â€¹x = a <= bâ€º â”‚  â€¹sle l1, l2 â†’ rvâ€º â”‚   ğ¬igned â”‚ ğ¥ess or ğqual    â”‚
â”‚              â”‚  â€¹ule l1, l2 â†’ rvâ€º â”‚ ğ®nsigned â”‚ ğ¥ess or ğqual    â”‚
â”‚ â€¹x = a >= bâ€º â”‚  â€¹sge l1, l2 â†’ rvâ€º â”‚   ğ¬igned â”‚ ğ reater or ğqual â”‚
â”‚              â”‚  â€¹uge l1, l2 â†’ rvâ€º â”‚ ğ®nsigned â”‚ ğ reater or ğqual â”‚

VÃ½sledek uloÅ¾enÃ½ do vÃ½stupnÃ­ho registru (vÂ pÅ™Ã­kladech vÃ½Å¡e â€¹rvâ€º)
je u instrukcÃ­ zÂ tÃ©to rodiny vÅ¾dy 1 (pravda) nebo 0 (nepravda). To
zejmÃ©na znamenÃ¡, Å¾e je moÅ¾nÃ© tyto vÃ½sledky kombinovat operacemi
â€¹andâ€º, â€¹orâ€º a â€¹xorâ€º a vÃ½sledek bude vÅ¾dy opÄ›t 0 nebo 1, vÂ souladu
sÂ definicÃ­ pÅ™Ã­sluÅ¡nÃ© logickÃ© operace (kÂ tÄ›mto se vrÃ¡tÃ­me nÃ­Å¾e).

## Å˜Ã­zenÃ­ toku

Abychom mohli realizovat podmÃ­nÄ›nÃ© pÅ™Ã­kazy a cykly, budeme kÂ tomu
potÅ™ebovat speciÃ¡lnÃ­ operace â€“ podobnÄ› jako pÅ™Ã­sluÅ¡nÃ½m pÅ™Ã­kazÅ¯m ve
vyÅ¡Å¡Ã­m jazyce jim budeme Å™Ã­kat Â«Å™Ã­zenÃ­ tokuÂ».

VÃ½poÄetnÃ­ stroj â€¹tinyâ€º obsahuje 3 operace tohoto typu:

 â€¢ â€¹jmp addrâ€º zpÅ¯sobÃ­, Å¾e vÃ½poÄet bude pokraÄovat od adresy â€¹addrâ€º
   â€“ bez ohledu na aktuÃ¡lnÃ­ stav registrÅ¯; adresu mÅ¯Å¾eme (a typicky
   budeme) zadÃ¡vat jako Â«symbolÂ» (jmÃ©no Â«nÃ¡vÄ›stÃ­Â» â€“ viz tÃ©Å¾ ÄÃ¡st
   B.3),
 â€¢ â€¹jz reg, addrâ€º (jump if zero) nejprve ovÄ›Å™Ã­, je-li hodnota
   registru â€¹regâ€º nulovÃ¡ â€“ pokud ano, provede skok stejnÄ› jako â€¹jmp
   addrâ€º, vÂ pÅ™Ã­padÄ› opaÄnÃ©m pokraÄuje na dalÅ¡Ã­ instrukci bez
   jakÃ©hokoliv dalÅ¡Ã­ho efektu,
 â€¢ â€¹jnz reg, addrâ€º (jump if not zero) se chovÃ¡ stejnÄ›, ale skok
   provede pouze je-li hodnota uloÅ¾enÃ¡ vÂ â€¹regâ€º nenulovÃ¡.

VÂ kombinaci sÂ aritmetickÃ½mi a srovnÃ¡vacÃ­mi operacemi popsanÃ½mi vÃ½Å¡e
dokÃ¡Å¾eme zapsat jednoduchou podmÃ­nku napÅ™. takto (odpovÃ­dajÃ­cÃ­
program vÂ Python-u je uveden vÂ komentÃ¡Å™Ã­ch):

        put 1     â†’ l1 ; a = 1
        slt l1, 3 â†’ t1 ; t = a < 3
        jz  t1, else   ; if t:
    then:
        put 2     â†’ l2 ;     b = 2
        jmp endif      ; else:
    else:
        put 3     â†’ l2 ;     b = 3
    endif:
        halt

Zkuste si program spustit pomocÃ­ â€¹tinyvm.pyâ€º zÂ kapitoly B, a takÃ©
upravit prvnÃ­ instrukci na â€¹put 5 â†’ l1â€º a srovnejte vÃ½sledek.
PodobnÄ› mÅ¯Å¾eme zapsat takÃ© â€¹whileâ€º cyklus (cykly â€¹forâ€º do strojovÃ©ho
kÃ³du pÅ™Ã­mo pÅ™epsat nemÅ¯Å¾eme, ale jak jistÄ› vÃ­te, je vÅ¾dy moÅ¾nÃ©
nejprve je pÅ™epsat na cykly â€¹whileâ€º). UvaÅ¾me tento velmi jednoduchÃ½
program vÂ Pythonu:

    a = 1
    while a < 3:
        a += 1

PÅ™epis do strojovÃ©ho kÃ³du bude opÄ›t vyÅ¾adovat urÄitou kreativitu,
protoÅ¾e mÃ¡me pouze instrukce skoku, nikoliv instrukce cyklu. StaÄÃ­
si ale uvÄ›domit, Å¾e â€¹while Trueâ€º se realizuje snadno: pomocÃ­
nepodmÃ­nÄ›nÃ©ho skoku zpÄ›t (na niÅ¾Å¡Ã­ adresu).

        put 1     â†’ l1   ; a = 1
    loop:                ; while True:
        slt l1, 3 â†’ t1   ;     t = a < 3
        jz  t1, end      ;     if not t: break
        add l1, 1 â†’ l1   ;     a += 1
        jmp loop
    end:
        halt

Cyklus â€¹while podmÃ­nkaâ€º jsme pÅ™epsali na â€¹while Trueâ€º a podmÃ­nÄ›nÃ½
â€¹breakâ€º â€“ ekvivalenci tÄ›chto dvou zÃ¡pisÅ¯ si rozmyslete.

## BitovÃ© logickÃ© operace

Operace, kterÃ© slovo interpretujÃ­ jako sekvenci bitÅ¯ a provÃ¡dÃ­
soubÄ›Å¾nÄ› tu stejnou logickou operaci na odpovÃ­dajÃ­cÃ­ch bitech,
nazÃ½vÃ¡me bitovÃ½mi logickÃ½mi operacemi â€“ jsou to â€¹orâ€º, â€¹andâ€º, â€¹xorâ€º.

Tyto operace zÃ­skajÃ­ âŸ¦iâŸ§-tÃ½ bit vÃ½sledku pomocÃ­ pÅ™Ã­sluÅ¡nÃ© logickÃ©
operace provedenÃ© na âŸ¦iâŸ§-tÃ©m bitu levÃ©ho a âŸ¦iâŸ§-tÃ©m bitu pravÃ©ho
operandu. Jinak Å™eÄeno, kaÅ¾dÃ½ bit vÃ½sledku zÃ¡visÃ­ pouze na jednom
bitu obou operandÅ¯ (napÅ™. uÂ aritmetickÃ½ch operacÃ­ to neplatÃ­).

Instrukce majÃ­ tyto tvary:

 â€¢ â€¹or  l1, l2 â†’ rvâ€º â€“ provede logickou disjunkci po bitech,
 â€¢ â€¹and l1, l2 â†’ rvâ€º â€“ provede logickou konjunkci po bitech,
 â€¢ â€¹xor l1, l2 â†’ rvâ€º â€“ provede negaci logickÃ© ekvivalence po bitech
   (vÃ½slednÃ½ bit je 1, je-li prÃ¡vÄ› jeden ze vstupnÃ­ch bitÅ¯ 1).

ExistujÃ­ takÃ© verze sÂ pÅ™Ã­mÃ½m operandem â€“ â€¹or l1, imm â†’ rvâ€º, atp.
Logickou negaci je pak moÅ¾nÃ© zapsat jako â€¹xor l1, ffff â†’ rvâ€º.

## BitovÃ© posuvy

Operace pro bitovÃ© posuvy realizujÃ­ nÃ¡sobenÃ­ a dÄ›lenÃ­ mocninami 2
(tzn. hodnotami 2, 4, 8, 16, 32, 64 â€¦). DruhÃ½ operand urÄuje, kterÃ¡
mocnina 2 se pouÅ¾ije (tzn. posuv oÂ 3 bity realizuje nÃ¡sobenÃ­/dÄ›lenÃ­
ÄÃ­slem âŸ¦2Â³ = 8âŸ§). ProtoÅ¾e dÄ›lenÃ­ existuje ve dvou variantÃ¡ch (se
znamÃ©nkem nebo bez), bitovÃ½ posuv doprava existuje takÃ© ve dvou
verzÃ­ch â€“ logickÃ½ (bez znamÃ©nka) a aritmetickÃ½ (se znamÃ©nkem).

Instrukce majÃ­ tyto tvary:

 â€¢ â€¹shl l1, l2 â†’ rvâ€º â€“ bitovÃ½ posuv doleva o â€¹l2â€º bitÅ¯ (nÃ¡sobenÃ­),
 â€¢ â€¹shr l1, l2 â†’ rvâ€º â€“ bitovÃ½ posuv doprava o â€¹l2â€º bitÅ¯ (dÄ›lenÃ­ bez
   znamÃ©nka),
 â€¢ â€¹sar l1, l2 â†’ rvâ€º â€“ bitovÃ½ posuv doprava o â€¹l2â€º bitÅ¯, ale mÃ­sto
   doplnÄ›nÃ­ nulami se kopÃ­ruje znamÃ©nkovÃ½ bit (dÄ›lenÃ­ se znamÃ©nka).

VÅ¡echny operace lze takÃ© pouÅ¾Ã­t ve formÃ¡ch sÂ pÅ™Ã­mÃ½m operandem: â€¹shl
l1, imm â†’ rvâ€º nebo â€¹shl imm, l2 â†’ rvâ€º.
